// Generated by Haxe 4.0.0
(function ($hx_exports) { "use strict";
var ArrayHelper = function() { };
ArrayHelper.__name__ = true;
ArrayHelper.max = function(arr) {
	return Lambda.fold(arr,function(max,n) {
		if(max == null) {
			return n;
		}
		if(n > max) {
			return n;
		} else {
			return max;
		}
	},null);
};
ArrayHelper.eq = function(arr1,arr2) {
	if(arr1.length != arr2.length) {
		return false;
	}
	var _g1 = 0;
	var _g = arr1.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(arr1[i] != arr2[i]) {
			return false;
		}
	}
	return true;
};
ArrayHelper.hasBlank = function(arr) {
	var _g = 0;
	while(_g < arr.length) {
		var v = arr[_g];
		++_g;
		if(Type.enumEq(v,State.Blank)) {
			return true;
		}
	}
	return false;
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.fold = function(it,f,first) {
	var x = $iterator(it)();
	while(x.hasNext()) {
		var x1 = x.next();
		first = f(x1,first);
	}
	return first;
};
Math.__name__ = true;
var Matrix = function(width,height) {
	this.isChanged = false;
	this.width = width;
	this.height = height;
	this.matrix = [];
	var _g1 = 0;
	var _g = height;
	while(_g1 < _g) {
		var y = _g1++;
		var row = [];
		var _g3 = 0;
		var _g2 = width;
		while(_g3 < _g2) {
			var x = _g3++;
			row.push(State.Blank);
		}
		this.matrix.push(row);
	}
};
Matrix.__name__ = true;
Matrix.toGroups = function(list) {
	var kind = null;
	var groups = [];
	var n = 0;
	var _g1 = 0;
	var _g = list.length;
	while(_g1 < _g) {
		var i = _g1++;
		var state = list[i];
		if(!Type.enumEq(kind,state)) {
			if(kind != null && n > 0) {
				groups.push(StateHelper.toGroup(kind,n));
			}
			kind = state;
			n = 1;
		} else {
			++n;
		}
	}
	if(kind != null && n > 0) {
		groups.push(StateHelper.toGroup(kind,n));
	}
	if(groups.length == 0) {
		return [];
	} else {
		return groups;
	}
};
Matrix.toNumbers = function(list) {
	var nums = [];
	var n = 0;
	var _g1 = 0;
	var _g = list.length;
	while(_g1 < _g) {
		var i = _g1++;
		var state = list[i];
		if(Type.enumEq(state,State.Blank) || Type.enumEq(state,State.Cross)) {
			if(n > 0) {
				nums.push(n);
				n = 0;
			}
		} else {
			++n;
		}
	}
	if(n > 0) {
		nums.push(n);
	}
	if(nums.length == 0) {
		return [0];
	} else {
		return nums;
	}
};
Matrix.prototype = {
	get: function(x,y) {
		return this.matrix[y][x];
	}
	,set: function(x,y,v) {
		if(this.matrix[y][x] != v) {
			this.isChanged = true;
		}
		return this.matrix[y][x] = v;
	}
	,row: function(y) {
		return this.matrix[y];
	}
	,column: function(x) {
		var _g = [];
		var _g2 = 0;
		var _g1 = this.height;
		while(_g2 < _g1) {
			var y = _g2++;
			_g.push(this.matrix[y][x]);
		}
		return _g;
	}
	,rowReplaceBlankToCross: function(y) {
		var _g1 = 0;
		var _g = this.width;
		while(_g1 < _g) {
			var x = _g1++;
			if(Type.enumEq(this.matrix[y][x],State.Blank)) {
				this.matrix[y][x] = State.Cross;
			}
		}
	}
	,columnReplaceBlankToCross: function(x) {
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(Type.enumEq(this.matrix[y][x],State.Blank)) {
				this.matrix[y][x] = State.Cross;
			}
		}
	}
	,rowToNumbers: function(y) {
		return Matrix.toNumbers(this.row(y));
	}
	,columnToNumbers: function(x) {
		return Matrix.toNumbers(this.column(x));
	}
	,rowToGroup: function(y) {
		return Matrix.toGroups(this.row(y));
	}
	,columnToGroup: function(x) {
		return Matrix.toGroups(this.column(x));
	}
	,hasBlank: function() {
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			var _g3 = 0;
			var _g2 = this.width;
			while(_g3 < _g2) {
				var x = _g3++;
				if(Type.enumEq(this.matrix[y][x],State.Blank)) {
					return true;
				}
			}
		}
		return false;
	}
	,hasBlankInRow: function(y) {
		var _g1 = 0;
		var _g = this.width;
		while(_g1 < _g) {
			var x = _g1++;
			if(Type.enumEq(this.matrix[y][x],State.Blank)) {
				return true;
			}
		}
		return false;
	}
	,hasBlankInColumn: function(x) {
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(Type.enumEq(this.matrix[y][x],State.Blank)) {
				return true;
			}
		}
		return false;
	}
	,toString: function() {
		return this.matrix.map(function(row) {
			return row.map(function(v) {
				switch(v[1]) {
				case 0:
					return "_";
				case 1:
					return "#";
				case 2:
					return "-";
				}
			}).join("");
		}).join("\n");
	}
};
var Problem = function(json) {
	var problem = JSON.parse(json);
	this.rows = problem.rows;
	this.columns = problem.columns;
	this.rowDepth = this.getDepth(this.rows);
	this.columnDepth = this.getDepth(this.columns);
	this.width = this.columns.length;
	this.height = this.rows.length;
};
Problem.__name__ = true;
Problem.prototype = {
	getDepth: function(nums_list) {
		return ArrayHelper.max(nums_list.map(function(v) {
			return v.length;
		}));
	}
};
var Solver = $hx_exports["Solver"] = function() {
};
Solver.__name__ = true;
Solver.prototype = {
	getMatrix: function() {
		return this.matrix;
	}
	,getMatrixString: function() {
		return this.matrix.toString();
	}
	,getStatus: function() {
		return this.status;
	}
	,readFromJson: function(json) {
		this.problem = new Problem(json);
		this.width = this.problem.width;
		this.height = this.problem.height;
	}
	,stepLog: function(row_or_column,index,step,message) {
	}
	,logMatrix: function(matrix,step) {
	}
	,calcSharedArea: function(nums,row) {
		if(nums.length == 0) {
			return haxe_ds_Option.None;
		}
		if(nums.length == 1 && nums[0] == 0) {
			return haxe_ds_Option.None;
		}
		var len = row.length;
		var first_num = nums[0];
		var rest_nums = nums.slice(1,nums.length);
		var sum = Lambda.fold(rest_nums,function(n,num) {
			return n + num + 1;
		},first_num);
		var max = ArrayHelper.max(nums);
		if(len - sum < max) {
			var dots = row.slice(0,row.length);
			var rest_len = len;
			var n1 = null;
			var _g1 = 0;
			var _g = nums.length;
			while(_g1 < _g) {
				var i = _g1++;
				var id = nums.length - i - 1;
				if(i > 0) {
					sum -= n1 + 1;
					rest_len -= n1 + 1;
				}
				n1 = nums[id];
				var diff_edge = rest_len - sum;
				var diff_num = n1 - diff_edge;
				var fill_first = sum - diff_num;
				var fill_last = sum;
				if(diff_num > 0) {
					var _g3 = fill_first;
					var _g2 = fill_last;
					while(_g3 < _g2) {
						var j = _g3++;
						dots[j] = State.Filled;
					}
				}
			}
			var _g11 = 0;
			var _g4 = len;
			while(_g11 < _g4) {
				var i1 = _g11++;
				if(!Type.enumEq(row[i1],dots[i1])) {
					return haxe_ds_Option.Some(dots);
				}
			}
			return haxe_ds_Option.None;
		} else {
			return haxe_ds_Option.None;
		}
	}
	,calcUnreachableAndMergeFilled: function(_nums,_list) {
		if(_nums.length == 1 && StateHelper.hasBlank(_list) && StateHelper.hasFilled(_list)) {
			var list = _list.slice(0,_list.length);
			var left = StateHelper.mostLeftFilledIndex(list);
			var right = StateHelper.mostRightFilledIndex(list);
			var w = right - left + 1;
			var diff = _nums[0] - w;
			var _g1 = left;
			var _g = right + 1;
			while(_g1 < _g) {
				var i = _g1++;
				if(Type.enumEq(list[i],State.Blank)) {
					list[i] = State.Filled;
				}
			}
			var c = 0;
			var i1 = left;
			while(--i1 >= 0) {
				if(c >= diff) {
					list[i1] = State.Cross;
				}
				++c;
			}
			var c1 = 0;
			var i2 = right;
			while(++i2 < list.length) {
				if(c1 >= diff) {
					list[i2] = State.Cross;
				}
				++c1;
			}
			return list;
		} else {
			return _list;
		}
	}
	,calcExtendEdge: function(_nums,_list) {
		if(_nums.length < 1) {
			return haxe_ds_Option.None;
		}
		var sh = this.smartShrink(_nums,_list);
		var left = sh.left;
		var list = sh.list;
		var nums = sh.nums;
		var result = _list.slice(0,_list.length);
		var gr = StateHelper.toGroups(list);
		if(Type.enumEq(list[0],State.Filled) && list.length > nums[0]) {
			var _g1 = 0;
			var _g = nums[0];
			while(_g1 < _g) {
				var i = _g1++;
				result[left + i] = State.Filled;
			}
		}
		if(Type.enumEq(list[list.length - 1],State.Filled) && list.length > nums[nums.length - 1]) {
			var l = list.length - nums[nums.length - 1];
			var _g11 = l;
			var _g2 = list.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				result[left + i1] = State.Filled;
			}
		}
		if(gr.length > 2 && list.length > nums[0] && StateHelper.isBlankGroup(gr[0]) && StateHelper.getCount(gr[0]) < nums[0] && StateHelper.isFilledGroup(gr[1]) && StateHelper.getCount(gr[1]) < nums[0]) {
			var n = StateHelper.getCount(gr[0]) + StateHelper.getCount(gr[1]);
			if(n < nums[0]) {
				var _g12 = n;
				var _g3 = nums[0];
				while(_g12 < _g3) {
					var i2 = _g12++;
					result[left + i2] = State.Filled;
				}
			}
		}
		if(gr.length > 2 && list.length > nums[nums.length - 1] && StateHelper.isBlankGroup(gr[gr.length - 1]) && StateHelper.getCount(gr[gr.length - 1]) < nums[nums.length - 1] && StateHelper.isFilledGroup(gr[gr.length - 2]) && StateHelper.getCount(gr[gr.length - 2]) < nums[nums.length - 1]) {
			var n1 = StateHelper.getCount(gr[gr.length - 1]) + StateHelper.getCount(gr[gr.length - 2]);
			if(n1 < nums[nums.length - 1]) {
				var _g13 = list.length - nums[nums.length - 1];
				var _g4 = list.length - n1;
				while(_g13 < _g4) {
					var i3 = _g13++;
					result[left + i3] = State.Filled;
				}
			}
		}
		if(gr.length > 1 && list.length > nums[0] && StateHelper.isBlankGroup(gr[0]) && StateHelper.getCount(gr[0]) <= nums[0] && StateHelper.isFilledGroup(gr[1]) && StateHelper.getCount(gr[1]) <= nums[0]) {
			var diff = StateHelper.getCount(gr[0]) + StateHelper.getCount(gr[1]) - nums[0];
			var _g14 = 0;
			var _g5 = diff;
			while(_g14 < _g5) {
				var i4 = _g14++;
				result[left + i4] = State.Cross;
			}
		}
		if(gr.length > 1 && list.length > nums[nums.length - 1] && StateHelper.isBlankGroup(gr[gr.length - 1]) && StateHelper.getCount(gr[gr.length - 1]) <= nums[nums.length - 1] && StateHelper.isFilledGroup(gr[gr.length - 2]) && StateHelper.getCount(gr[gr.length - 2]) <= nums[nums.length - 1]) {
			var diff1 = StateHelper.getCount(gr[gr.length - 1]) + StateHelper.getCount(gr[gr.length - 2]) - nums[nums.length - 1];
			var _g15 = list.length - diff1;
			var _g6 = list.length;
			while(_g15 < _g6) {
				var i5 = _g15++;
				result[left + i5] = State.Cross;
			}
		}
		return haxe_ds_Option.Some(result);
	}
	,extendEdge: function() {
		var flag = false;
		var flag_line = false;
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				var nums = this.problem.rows[y];
				var row = this.matrix.row(y);
				var result = this.calcExtendEdge(nums,row);
				switch(result[1]) {
				case 0:
					var list = result[2];
					flag_line = false;
					var _g3 = 0;
					var _g2 = this.width;
					while(_g3 < _g2) {
						var x = _g3++;
						if(this.matrix.get(x,y) != list[x]) {
							this.matrix.set(x,y,list[x]);
							flag = true;
							flag_line = true;
						}
					}
					if(flag_line) {
						this.step += 1;
						this.stepLog("row",y,this.step,"extend edge");
						this.logMatrix(this.matrix,this.step);
					}
					continue;
				case 1:
					continue;
				}
			}
		}
		var _g11 = 0;
		var _g4 = this.width;
		while(_g11 < _g4) {
			var x1 = _g11++;
			if(this.matrix.hasBlankInColumn(x1)) {
				var nums1 = this.problem.columns[x1];
				var column = this.matrix.column(x1);
				var result1 = this.calcExtendEdge(nums1,column);
				switch(result1[1]) {
				case 0:
					var list1 = result1[2];
					flag_line = false;
					var _g31 = 0;
					var _g21 = this.height;
					while(_g31 < _g21) {
						var y1 = _g31++;
						if(this.matrix.get(x1,y1) != list1[y1]) {
							this.matrix.set(x1,y1,list1[y1]);
							flag = true;
							flag_line = true;
						}
					}
					if(flag_line) {
						this.step += 1;
						this.stepLog("col",x1,this.step,"extend edge");
						this.logMatrix(this.matrix,this.step);
					}
					continue;
				case 1:
					continue;
				}
			}
		}
		return flag;
	}
	,splitByCrossAndFill: function() {
		var flag = false;
		var flag_line = false;
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				var nums = this.problem.rows[y];
				var row = this.matrix.row(y);
				var result = this.calcSplitByCrossAndFill(nums,row);
				switch(result[1]) {
				case 0:
					var list = result[2];
					flag_line = false;
					var _g3 = 0;
					var _g2 = this.width;
					while(_g3 < _g2) {
						var x = _g3++;
						if(this.matrix.get(x,y) != list[x]) {
							this.matrix.set(x,y,list[x]);
							flag = true;
							flag_line = true;
						}
					}
					if(flag_line) {
						this.step += 1;
						this.stepLog("row",y,this.step,"split by cross, and fill");
						this.logMatrix(this.matrix,this.step);
					}
					continue;
				case 1:
					continue;
				}
			}
		}
		var _g11 = 0;
		var _g4 = this.width;
		while(_g11 < _g4) {
			var x1 = _g11++;
			if(this.matrix.hasBlankInColumn(x1)) {
				var nums1 = this.problem.columns[x1];
				var column = this.matrix.column(x1);
				var result1 = this.calcSplitByCrossAndFill(nums1,column);
				switch(result1[1]) {
				case 0:
					var list1 = result1[2];
					flag_line = false;
					var _g31 = 0;
					var _g21 = this.height;
					while(_g31 < _g21) {
						var y1 = _g31++;
						if(this.matrix.get(x1,y1) != list1[y1]) {
							this.matrix.set(x1,y1,list1[y1]);
							flag = true;
							flag_line = true;
						}
					}
					if(flag_line) {
						this.step += 1;
						this.stepLog("col",x1,this.step,"split by cross, and fill");
						this.logMatrix(this.matrix,this.step);
					}
					continue;
				case 1:
					continue;
				}
			}
		}
		return flag;
	}
	,calcSplitByCrossAndFill: function(_nums,_list) {
		var splitted = this.splitByCross(_list);
		var filled_count = splitted.filter(function(lwo) {
			return StateHelper.hasFilled(lwo.list);
		}).length;
		var list = _list.slice(0,_list.length);
		if(filled_count == _nums.length) {
			var filled_index = 0;
			var _g1 = 0;
			var _g = splitted.length;
			while(_g1 < _g) {
				var i = _g1++;
				var lwo1 = splitted[i];
				var left = lwo1.left;
				var num = _nums[filled_index];
				if(StateHelper.hasFilled(lwo1.list)) {
					var result = this.calcSharedArea([num],lwo1.list);
					switch(result[1]) {
					case 0:
						var ls = result[2];
						var _g3 = 0;
						var _g2 = ls.length;
						while(_g3 < _g2) {
							var i1 = _g3++;
							list[left + i1] = ls[i1];
							lwo1.list[i1] = ls[i1];
						}
						break;
					case 1:
						break;
					}
					var l = this.calcUnreachableAndMergeFilled([num],lwo1.list);
					var _g31 = 0;
					var _g21 = l.length;
					while(_g31 < _g21) {
						var i2 = _g31++;
						list[left + i2] = l[i2];
					}
					++filled_index;
				} else {
					var _g32 = 0;
					var _g22 = lwo1.list.length;
					while(_g32 < _g22) {
						var i3 = _g32++;
						list[left + i3] = State.Cross;
					}
				}
			}
			return haxe_ds_Option.Some(list);
		} else if(splitted.length == _nums.length) {
			if(_nums.length > 1) {
				var _g11 = 0;
				var _g4 = splitted.length;
				while(_g11 < _g4) {
					var i4 = _g11++;
					if(splitted[i4].list.length < _nums[i4]) {
						return haxe_ds_Option.None;
					}
				}
				var filt_sp = splitted.slice(0,splitted.length);
				var filt_nums = _nums.slice(0,_nums.length);
				var prev_num = -1;
				while(true) if(filt_sp.length > 0 && filt_nums.length > 0) {
					if(filt_nums.length > 1 && filt_sp[0].list.length >= filt_nums[0] + filt_nums[1] + 1) {
						return haxe_ds_Option.None;
					} else if(prev_num > -1 && filt_sp[0].list.length >= prev_num + filt_nums[0] + 1) {
						return haxe_ds_Option.None;
					} else {
						filt_sp = filt_sp.slice(1,filt_sp.length);
						prev_num = filt_nums[0];
						filt_nums = filt_nums.slice(1,filt_nums.length);
						continue;
					}
				} else {
					break;
				}
				if(filt_nums.length > 1) {
					var sum = Lambda.fold(filt_nums,function(n,num1) {
						return n + num1 + 1;
					},0);
					var _g12 = 0;
					var _g5 = filt_sp.length;
					while(_g12 < _g5) {
						var i5 = _g12++;
						if(filt_sp[i5].list.length > sum) {
							return haxe_ds_Option.None;
						}
					}
				}
			}
			var _g13 = 0;
			var _g6 = splitted.length;
			while(_g13 < _g6) {
				var i6 = _g13++;
				var lwo2 = splitted[i6];
				var left1 = lwo2.left;
				var num2 = _nums[i6];
				var result1 = this.calcSharedArea([num2],lwo2.list);
				switch(result1[1]) {
				case 0:
					var ls1 = result1[2];
					var _g33 = 0;
					var _g23 = ls1.length;
					while(_g33 < _g23) {
						var i7 = _g33++;
						list[left1 + i7] = ls1[i7];
						lwo2.list[i7] = ls1[i7];
					}
					break;
				case 1:
					break;
				}
				var l1 = this.calcUnreachableAndMergeFilled([num2],lwo2.list);
				var _g34 = 0;
				var _g24 = l1.length;
				while(_g34 < _g24) {
					var i8 = _g34++;
					list[left1 + i8] = l1[i8];
				}
			}
			return haxe_ds_Option.Some(list);
		}
		return haxe_ds_Option.None;
	}
	,splitByCross: function(_list) {
		var sh = this.simpleShrink(_list);
		var list = sh.list;
		var left = sh.left;
		var start = 0;
		var retList = [];
		var gr = StateHelper.toGroups(list);
		var count = function(gr1) {
			var n = 0;
			var _g = 0;
			while(_g < gr1.length) {
				var sg = gr1[_g];
				++_g;
				n += StateHelper.getCount(sg);
			}
			return n;
		};
		var ret = function(_gr,_ls,_start,_end) {
			var edge_gr = _gr.slice(0,_start);
			var sub_gr = _gr.slice(0,_end + 1);
			var _left = count(edge_gr);
			var len = count(sub_gr);
			return { left : left + _left, list : _ls.slice(_left,len)};
		};
		var _g1 = 0;
		var _g2 = gr.length;
		while(_g1 < _g2) {
			var i = _g1++;
			if(StateHelper.isCrossGroup(gr[i])) {
				retList.push(ret(gr,list,start,i - 1));
				start = i + 1;
			}
		}
		retList.push(ret(gr,list,start,gr.length - 1));
		return retList;
	}
	,smartCrossAndFill: function() {
		var flag = false;
		var flag_line = false;
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				var nums = this.problem.rows[y];
				var row = this.matrix.row(y);
				var result = this.calcSmartCrossAndFill(nums,row);
				switch(result[1]) {
				case 0:
					var list = result[2];
					flag_line = false;
					var _g3 = 0;
					var _g2 = this.width;
					while(_g3 < _g2) {
						var x = _g3++;
						if(this.matrix.get(x,y) != list[x]) {
							this.matrix.set(x,y,list[x]);
							flag = true;
							flag_line = true;
						}
					}
					if(flag_line) {
						this.step += 1;
						this.stepLog("row",y,this.step,"smart cross and fill");
						this.logMatrix(this.matrix,this.step);
					}
					continue;
				case 1:
					continue;
				}
			}
		}
		var _g11 = 0;
		var _g4 = this.width;
		while(_g11 < _g4) {
			var x1 = _g11++;
			if(this.matrix.hasBlankInColumn(x1)) {
				var nums1 = this.problem.columns[x1];
				var column = this.matrix.column(x1);
				var result1 = this.calcSmartCrossAndFill(nums1,column);
				switch(result1[1]) {
				case 0:
					var list1 = result1[2];
					flag_line = false;
					var _g31 = 0;
					var _g21 = this.height;
					while(_g31 < _g21) {
						var y1 = _g31++;
						if(this.matrix.get(x1,y1) != list1[y1]) {
							this.matrix.set(x1,y1,list1[y1]);
							flag = true;
							flag_line = true;
						}
					}
					if(flag_line) {
						this.step += 1;
						this.stepLog("col",x1,this.step,"smart cross and fill");
						this.logMatrix(this.matrix,this.step);
					}
					continue;
				case 1:
					continue;
				}
			}
		}
		return flag;
	}
	,calcSmartCrossAndFill: function(_nums,_list) {
		var list = _list.slice(0,_list.length);
		var orig_len = list.length;
		var result = _list.slice(0,_list.length);
		var nums = _nums.slice(0,_nums.length);
		var left = 0;
		var right = 0;
		var changed = false;
		var ret = function() {
			if(changed) {
				return haxe_ds_Option.Some(result);
			} else {
				return haxe_ds_Option.None;
			}
		};
		while(true) {
			var sh = this.simpleShrink(list,left);
			right = _list.length - sh.list.length - sh.left;
			list = sh.list;
			left = sh.left;
			if(list.length == 0 || nums.length == 0) {
				return ret();
			}
			var gr = StateHelper.toGroups(list);
			if(gr.length < 2) {
				return ret();
			}
			var gr_len = gr.length;
			var first_num = nums[0];
			var last_num = nums[nums.length - 1];
			if(StateHelper.isFilledGroup(gr[0]) && StateHelper.getCount(gr[0]) == first_num && StateHelper.isCrossGroup(gr[1])) {
				list = list.slice(first_num + 1,list.length);
				left += first_num + 1;
				nums = nums.slice(1,nums.length);
				continue;
			} else if(StateHelper.isFilledGroup(gr[gr_len - 1]) && StateHelper.getCount(gr[gr_len - 1]) == last_num && StateHelper.isCrossGroup(gr[gr_len - 2])) {
				list = list.slice(0,list.length - last_num - 1);
				right += last_num + 1;
				nums = nums.slice(0,nums.length - 1);
				continue;
			}
			if(StateHelper.isFilledGroup(gr[0]) && StateHelper.getCount(gr[0]) == first_num && StateHelper.isBlankGroup(gr[1])) {
				result[left + first_num] = State.Cross;
				list = list.slice(first_num + 1,list.length);
				left += first_num + 1;
				nums = nums.slice(1,nums.length);
			} else if(gr.length > 2 && StateHelper.isBlankGroup(gr[0]) && StateHelper.getCount(gr[0]) <= first_num && StateHelper.isFilledGroup(gr[1]) && StateHelper.getCount(gr[1]) == first_num && StateHelper.isBlankGroup(gr[2])) {
				var edge_count = StateHelper.getCount(gr[0]);
				var _g1 = left;
				var _g = left + edge_count;
				while(_g1 < _g) {
					var i = _g1++;
					result[i] = State.Cross;
				}
				result[left + edge_count + first_num] = State.Cross;
				list = list.slice(first_num + edge_count + 1,list.length);
				left += first_num + edge_count + 1;
				nums = nums.slice(1,nums.length);
			} else if(StateHelper.isBlankGroup(gr[0]) && StateHelper.getCount(gr[0]) < first_num && StateHelper.isCrossGroup(gr[1])) {
				var edge_count1 = StateHelper.getCount(gr[0]);
				var _g11 = left;
				var _g2 = left + edge_count1;
				while(_g11 < _g2) {
					var i1 = _g11++;
					result[i1] = State.Cross;
				}
				list = list.slice(edge_count1 + 1,list.length);
				left += edge_count1 + 1;
			} else if(StateHelper.isFilledGroup(gr[gr_len - 1]) && StateHelper.getCount(gr[gr_len - 1]) == last_num && StateHelper.isBlankGroup(gr[gr_len - 2])) {
				result[orig_len - 1 - right - last_num] = State.Cross;
				list = list.slice(0,list.length - last_num - 1);
				right += last_num + 1;
				nums = nums.slice(0,nums.length - 1);
			} else if(gr.length > 2 && StateHelper.isBlankGroup(gr[gr_len - 1]) && StateHelper.getCount(gr[gr_len - 1]) <= last_num && StateHelper.isFilledGroup(gr[gr_len - 2]) && StateHelper.getCount(gr[gr_len - 2]) == last_num && StateHelper.isBlankGroup(gr[gr_len - 3])) {
				var edge_count2 = StateHelper.getCount(gr[gr_len - 1]);
				var _g12 = orig_len - right - edge_count2;
				var _g3 = orig_len - right;
				while(_g12 < _g3) {
					var i2 = _g12++;
					result[i2] = State.Cross;
				}
				result[orig_len - 1 - right - last_num - edge_count2] = State.Cross;
				list = list.slice(0,list.length - last_num - edge_count2 - 1);
				right += last_num + edge_count2 + 1;
				nums = nums.slice(0,nums.length - 1);
			} else if(StateHelper.isBlankGroup(gr[gr_len - 1]) && StateHelper.getCount(gr[gr_len - 1]) < last_num && StateHelper.isCrossGroup(gr[gr_len - 2])) {
				var edge_count3 = StateHelper.getCount(gr[gr_len - 1]);
				var _g13 = orig_len - right - edge_count3;
				var _g4 = orig_len - right;
				while(_g13 < _g4) {
					var i3 = _g13++;
					result[i3] = State.Cross;
				}
				result[orig_len - right - edge_count3] = State.Cross;
				list = list.slice(0,list.length - edge_count3 - 1);
				right += edge_count3 + 1;
			} else {
				return ret();
			}
			changed = true;
		}
	}
	,smartShrink: function(_nums,_list,left_offset) {
		if(left_offset == null) {
			left_offset = 0;
		}
		var list = _list.slice(0,_list.length);
		var nums = _nums.slice(0,_nums.length);
		var left = left_offset;
		while(true) {
			var sh = this.simpleShrink(list,left);
			list = sh.list;
			left = sh.left;
			if(list.length == 0 || nums.length == 0) {
				return { list : list, left : left, nums : nums};
			}
			var gr = StateHelper.toGroups(list);
			if(gr.length < 2) {
				return { list : list, left : left, nums : nums};
			}
			var gr_len = gr.length;
			var first_num = nums[0];
			var last_num = nums[nums.length - 1];
			if(StateHelper.isFilledGroup(gr[0]) && StateHelper.getCount(gr[0]) == first_num && StateHelper.isCrossGroup(gr[1])) {
				var cross_count = StateHelper.getCount(gr[1]);
				list = list.slice(first_num + cross_count,list.length);
				left = left + first_num + cross_count;
				nums = nums.slice(1,nums.length);
			} else if(StateHelper.isFilledGroup(gr[gr_len - 1]) && StateHelper.getCount(gr[gr_len - 1]) == last_num && StateHelper.isCrossGroup(gr[gr_len - 2])) {
				var cross_count1 = StateHelper.getCount(gr[gr_len - 2]);
				list = list.slice(0,list.length - last_num - cross_count1);
				nums = nums.slice(0,nums.length - 1);
			} else {
				return { list : list, left : left, nums : nums};
			}
		}
	}
	,simpleShrink: function(_list,left_offset) {
		if(left_offset == null) {
			left_offset = 0;
		}
		var list = _list;
		var left = left_offset;
		while(true) {
			if(list.length == 0) {
				return { list : list, left : left};
			}
			if(Type.enumEq(list[0],State.Cross)) {
				list = list.slice(1,list.length);
				++left;
			} else if(Type.enumEq(list[list.length - 1],State.Cross)) {
				list = list.slice(0,list.length - 1);
			} else {
				return { list : list, left : left};
			}
		}
	}
	,smartShrinkingSharedAreaMethod: function() {
		var flag = false;
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				var nums = this.problem.rows[y];
				var row = this.matrix.row(y);
				var shrinked = this.smartShrink(nums,row);
				var left = shrinked.left;
				var result = this.calcSharedArea(shrinked.nums,shrinked.list);
				switch(result[1]) {
				case 0:
					var list = result[2];
					var _g3 = left;
					var _g2 = shrinked.list.length + left;
					while(_g3 < _g2) {
						var x = _g3++;
						this.matrix.set(x,y,list[x - left]);
					}
					this.step += 1;
					if(row.length == shrinked.list.length) {
						this.stepLog("row",y,this.step,"smart shared area method");
					} else {
						this.stepLog("row",y,this.step,"smart shrinking shared area method");
					}
					this.logMatrix(this.matrix,this.step);
					flag = true;
					continue;
				case 1:
					continue;
				}
			}
		}
		var _g11 = 0;
		var _g4 = this.width;
		while(_g11 < _g4) {
			var x1 = _g11++;
			if(this.matrix.hasBlankInColumn(x1)) {
				var nums1 = this.problem.columns[x1];
				var column = this.matrix.column(x1);
				var shrinked1 = this.smartShrink(nums1,column);
				var left1 = shrinked1.left;
				var result1 = this.calcSharedArea(shrinked1.nums,shrinked1.list);
				switch(result1[1]) {
				case 0:
					var list1 = result1[2];
					var _g31 = left1;
					var _g21 = list1.length + left1;
					while(_g31 < _g21) {
						var y1 = _g31++;
						if(!Type.enumEq(this.matrix.get(x1,y1),list1[y1 - left1])) {
							this.matrix.set(x1,y1,list1[y1 - left1]);
						}
					}
					this.step += 1;
					if(column.length == shrinked1.list.length) {
						this.stepLog("col",x1,this.step,"smart shared area method");
					} else {
						this.stepLog("col",x1,this.step,"smart shrinking shared area method");
					}
					this.logMatrix(this.matrix,this.step);
					flag = true;
					continue;
				case 1:
					continue;
				}
			}
		}
		return flag;
	}
	,simpleShrinkingSharedAreaMethod: function() {
		var flag = false;
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				var nums = this.problem.rows[y];
				var row = this.matrix.row(y);
				var shrinked = this.simpleShrink(row);
				var left = shrinked.left;
				var result = this.calcSharedArea(nums,shrinked.list);
				switch(result[1]) {
				case 0:
					var list = result[2];
					var _g3 = left;
					var _g2 = shrinked.list.length + left;
					while(_g3 < _g2) {
						var x = _g3++;
						this.matrix.set(x,y,list[x - left]);
					}
					this.step += 1;
					if(row.length == shrinked.list.length) {
						this.stepLog("row",y,this.step,"simple shared area method");
					} else {
						this.stepLog("row",y,this.step,"simple shrinking shared area method");
					}
					this.logMatrix(this.matrix,this.step);
					flag = true;
					continue;
				case 1:
					continue;
				}
			}
		}
		var _g11 = 0;
		var _g4 = this.width;
		while(_g11 < _g4) {
			var x1 = _g11++;
			if(this.matrix.hasBlankInColumn(x1)) {
				var nums1 = this.problem.columns[x1];
				var column = this.matrix.column(x1);
				var shrinked1 = this.simpleShrink(column);
				var left1 = shrinked1.left;
				var result1 = this.calcSharedArea(nums1,shrinked1.list);
				switch(result1[1]) {
				case 0:
					var list1 = result1[2];
					var _g31 = left1;
					var _g21 = list1.length + left1;
					while(_g31 < _g21) {
						var y1 = _g31++;
						this.matrix.set(x1,y1,list1[y1 - left1]);
					}
					this.step += 1;
					if(column.length == shrinked1.list.length) {
						this.stepLog("col",x1,this.step,"simple shared area method");
					} else {
						this.stepLog("col",x1,this.step,"simple shrinking shared area method");
					}
					this.logMatrix(this.matrix,this.step);
					flag = true;
					continue;
				case 1:
					continue;
				}
			}
		}
		return flag;
	}
	,simpleSharedAreaMethod: function() {
		var flag = false;
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				var nums = this.problem.rows[y];
				var row = this.matrix.row(y);
				var result = this.calcSharedArea(nums,row);
				switch(result[1]) {
				case 0:
					var list = result[2];
					var _g3 = 0;
					var _g2 = this.width;
					while(_g3 < _g2) {
						var x = _g3++;
						this.matrix.set(x,y,list[x]);
					}
					this.step += 1;
					this.stepLog("row",y,this.step,"simple shared area method");
					this.logMatrix(this.matrix,this.step);
					flag = true;
					continue;
				case 1:
					continue;
				}
			}
		}
		var _g11 = 0;
		var _g4 = this.width;
		while(_g11 < _g4) {
			var x1 = _g11++;
			if(this.matrix.hasBlankInColumn(x1)) {
				var nums1 = this.problem.columns[x1];
				var column = this.matrix.column(x1);
				var result1 = this.calcSharedArea(nums1,column);
				switch(result1[1]) {
				case 0:
					var list1 = result1[2];
					var _g31 = 0;
					var _g21 = this.height;
					while(_g31 < _g21) {
						var y1 = _g31++;
						this.matrix.set(x1,y1,list1[y1]);
					}
					this.step += 1;
					this.stepLog("col",x1,this.step,"simple shared area method");
					this.logMatrix(this.matrix,this.step);
					flag = true;
					continue;
				case 1:
					continue;
				}
			}
		}
		return flag;
	}
	,isCompleted: function() {
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				return false;
			}
		}
		var _g11 = 0;
		var _g2 = this.height;
		while(_g11 < _g2) {
			var x = _g11++;
			if(this.matrix.hasBlankInColumn(x)) {
				return false;
			}
		}
		return true;
	}
	,checkFixedAndCross: function() {
		var flag = false;
		var _g1 = 0;
		var _g = this.height;
		while(_g1 < _g) {
			var y = _g1++;
			if(this.matrix.hasBlankInRow(y)) {
				var nums = this.problem.rows[y];
				var row_nums = this.matrix.rowToNumbers(y);
				if(ArrayHelper.eq(nums,row_nums)) {
					flag = true;
					this.step += 1;
					this.matrix.rowReplaceBlankToCross(y);
					this.stepLog("row",y,this.step,"numbers completed");
					this.logMatrix(this.matrix,this.step);
				}
			}
		}
		var _g11 = 0;
		var _g2 = this.width;
		while(_g11 < _g2) {
			var x = _g11++;
			if(this.matrix.hasBlankInColumn(x)) {
				var nums1 = this.problem.columns[x];
				var column_nums = this.matrix.columnToNumbers(x);
				if(ArrayHelper.eq(nums1,column_nums)) {
					flag = true;
					this.step += 1;
					this.matrix.columnReplaceBlankToCross(x);
					this.stepLog("col",x,this.step,"numbers completed");
					this.logMatrix(this.matrix,this.step);
				}
			}
		}
		return flag;
	}
	,solve: function() {
		this.matrix = new Matrix(this.width,this.height);
		this.status = "";
		this.step = 0;
		while(this.matrix.hasBlank()) {
			this.matrix.isChanged = false;
			this.smartShrinkingSharedAreaMethod();
			this.smartCrossAndFill();
			this.extendEdge();
			this.splitByCrossAndFill();
			this.checkFixedAndCross();
			if(this.isCompleted()) {
				break;
			}
			if(this.matrix.isChanged == false) {
				this.status = "失敗 (" + this.step + " steps)";
				this.status += "\n" + ("rows: " + Std.string(this.problem.rows));
				this.status += "\n" + ("columns: " + Std.string(this.problem.columns));
				return false;
			}
		}
		this.status = "成功 (" + this.step + " steps)";
		this.logMatrix(this.matrix,this.step);
		return true;
	}
};
var State = { __ename__ : true, __constructs__ : ["Blank","Filled","Cross"] };
State.Blank = ["Blank",0];
State.Blank.__enum__ = State;
State.Filled = ["Filled",1];
State.Filled.__enum__ = State;
State.Cross = ["Cross",2];
State.Cross.__enum__ = State;
var StateGroup = { __ename__ : true, __constructs__ : ["BlankGroup","FilledGroup","CrossGroup"] };
StateGroup.BlankGroup = function(n) { var $x = ["BlankGroup",0,n]; $x.__enum__ = StateGroup; return $x; };
StateGroup.FilledGroup = function(n) { var $x = ["FilledGroup",1,n]; $x.__enum__ = StateGroup; return $x; };
StateGroup.CrossGroup = function(n) { var $x = ["CrossGroup",2,n]; $x.__enum__ = StateGroup; return $x; };
var StateHelper = function() { };
StateHelper.__name__ = true;
StateHelper.toGroup = function(state,n) {
	switch(state[1]) {
	case 0:
		return StateGroup.BlankGroup(n);
	case 1:
		return StateGroup.FilledGroup(n);
	case 2:
		return StateGroup.CrossGroup(n);
	}
};
StateHelper.toGroups = function(list) {
	return Matrix.toGroups(list);
};
StateHelper.toNumbers = function(list) {
	return Matrix.toNumbers(list);
};
StateHelper.toVisualString = function(list) {
	return list.map(function(state) {
		switch(state[1]) {
		case 0:
			return "_";
		case 1:
			return "#";
		case 2:
			return "/";
		}
	}).join("");
};
StateHelper.hasBlank = function(list) {
	var _g = 0;
	while(_g < list.length) {
		var s = list[_g];
		++_g;
		if(Type.enumEq(s,State.Blank)) {
			return true;
		}
	}
	return false;
};
StateHelper.hasFilled = function(list) {
	var _g = 0;
	while(_g < list.length) {
		var s = list[_g];
		++_g;
		if(Type.enumEq(s,State.Filled)) {
			return true;
		}
	}
	return false;
};
StateHelper.mostLeftFilledIndex = function(list) {
	var _g1 = 0;
	var _g = list.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(Type.enumEq(list[i],State.Filled)) {
			return i;
		}
	}
	return -1;
};
StateHelper.mostRightFilledIndex = function(list) {
	var i = list.length;
	while(--i >= 0) if(Type.enumEq(list[i],State.Filled)) {
		return i;
	}
	return -1;
};
StateHelper.isFilledGroup = function(s) {
	if(s[1] == 1) {
		return true;
	} else {
		return false;
	}
};
StateHelper.isCrossGroup = function(s) {
	if(s[1] == 2) {
		return true;
	} else {
		return false;
	}
};
StateHelper.isBlankGroup = function(s) {
	if(s[1] == 0) {
		return true;
	} else {
		return false;
	}
};
StateHelper.getCount = function(s) {
	switch(s[1]) {
	case 0:
		var n = s[2];
		return n;
	case 1:
		var n1 = s[2];
		return n1;
	case 2:
		var n2 = s[2];
		return n2;
	}
};
StateHelper.toStates = function(s) {
	var _g = [];
	var _g2 = 0;
	var _g1 = s.length;
	while(_g2 < _g1) {
		var i = _g2++;
		var _g3 = s.charAt(i);
		var tmp;
		switch(_g3) {
		case "#":
			tmp = State.Filled;
			break;
		case "/":
			tmp = State.Cross;
			break;
		case "_":
			tmp = State.Blank;
			break;
		default:
			tmp = null;
		}
		_g.push(tmp);
	}
	return _g;
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var Type = function() { };
Type.__name__ = true;
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		if(a[0] != b[0]) {
			return false;
		}
		var _g1 = 2;
		var _g = a.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(!Type.enumEq(a[i],b[i])) {
				return false;
			}
		}
		var e = a.__enum__;
		if(e != b.__enum__ || e == null) {
			return false;
		}
	} catch( e1 ) {
		return false;
	}
	return true;
};
var haxe_ds_Option = { __ename__ : true, __constructs__ : ["Some","None"] };
haxe_ds_Option.Some = function(v) { var $x = ["Some",0,v]; $x.__enum__ = haxe_ds_Option; return $x; };
haxe_ds_Option.None = ["None",1];
haxe_ds_Option.None.__enum__ = haxe_ds_Option;
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = ["Date"];
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);
